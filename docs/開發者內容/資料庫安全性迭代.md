# 📊 資料庫安全性迭代記錄

> 根據 Vercel Blob 使用經驗與生產環境反饋總結的資料安全防護演進

---

## 🚨 第一階段：初期問題（已解決）

### 問題 1：部署時資料被重置
**表現**：每次推送新版本後，用戶新增的專案全部消失，系統恢復到範例資料。

**根本原因**：
- 自動初始化 API 端點（`GET /api/initialize`）在啟動時檢查資料是否為空
- 冷啟動延遲導致 Blob 讀取超時，被誤判為空資料
- 系統自動用 `forceWrite=true` 覆蓋現有資料

**解決**：停用自動初始化端點，改為需要管理員明確授權的 POST 操作

---

### 問題 2：讀取失敗被當成空資料
**表現**：任何讀取錯誤（網路、權限、格式錯誤）都會返回預設空資料，觸發誤判初始化。

**根本原因**：
- `readProjectData()` 的 `catch` 區塊直接返回 `defaultProjectData`
- 無法區分「檔案不存在」與「讀取失敗」

**解決**：改為拋出 `ProjectDataError`，讓上層 API 攔截並返回錯誤訊息

---

### 問題 3：缺乏多層驗證保護
**表現**：寫入操作只檢查資料是否為空，沒有完整驗證鏈

**根本原因**：設計簡化過度，沒有考慮到邊界情況

**解決**：實施三層驗證（資料完整性 → 空資料檢查 → 安全鎖標記）

---

## ✅ 第二階段：本次改進內容

### 改進 1：強化讀取邏輯與錯誤處理

**做法**：
- 新增 `ProjectDataError` 錯誤類別，區分不同的失敗情況
  - `LOCAL_BACKUP_MODE_ENABLED`：偵測到本地備份模式
  - `BLOB_LIST_FAILED`：無法列出 Blob 檔案
  - `BLOB_FETCH_FAILED`：無法讀取 Blob 內容
  - `BLOB_PARSE_FAILED`：JSON 解析失敗
  - `BLOB_SCHEMA_INVALID`：資料格式驗證失敗

- 本地開發環境優雅降級：若無 `BLOB_READ_WRITE_TOKEN`，使用預設空資料繼續開發，而非拋錯
- 生產環境嚴格模式：讀取失敗直接拋錯，讓前端顯示「暫時無法操作」

**效果**：
- 開發者在本地無需設定 Vercel Blob token 即可運行
- 生產環境讀取失敗會被明確攔截，不會誤觸初始化

---

### 改進 2：防止本地備份模式意外覆蓋

**做法**：
- 檢測環境變數 `NEXT_PUBLIC_USE_LOCAL_BACKUP`
- 若該變數為 `true`，所有寫入操作直接拋出 `ProjectDataError`，回傳 503 錯誤
- 後台顯示醒目警告，禁止任何寫入操作

**效果**：
- 即使開發者忘記關閉本地備份模式，系統也會自動鎖定寫入
- 避免把舊快照覆蓋回雲端

---

### 改進 3：統一 API 端點的錯誤回應格式

**做法**：
- 所有 API 端點（專案 CRUD、排序、設定儲存）捕捉到錯誤時，統一回傳格式：
  ```
  {
    error: "簡短的中文說明",
    details: "英文錯誤訊息",
    translatedMessage: "⚠️ 詳細的繁中翻譯"
  }
  ```
- 讀取失敗時用 503 表示「暫時無法操作」
- 寫入失敗時用 500 表示「伺服器錯誤」

**效果**：
- 開發者可以快速理解問題（透過繁中翻譯）
- 其他開發者也能看到原始英文錯誤代碼進行除錯

---

### 改進 4：簡化密碼管理介面

**做法**：
- 移除後台「密碼管理」分頁及所有密碼相關 UI
- 保留管理員登入驗證功能（這是必要的）
- 批量導入邏輯改為僅處理專案列表，不再導入密碼

**效果**：
- UI 更簡潔，焦點集中在專案管理
- 減少不必要的功能複雜度

---

### 改進 5：本地開發模式優化

**做法**：
- Blob 寫入失敗時，不拋錯，而是返回模擬的寫入結果
- 記錄警告訊息：「本地開發模式，數據變更僅在記憶體中」
- 開發者可以正常進行本地測試而不會被 Blob 限制打斷

**效果**：
- 開發流程更流暢
- 在本地沒有配置 Vercel 也能完整測試功能

---

## 🔄 第三階段：數據一致性改進（2025-10-23）

### 問題：CDN 緩存導致的數據不一致

**表現**：
- 管理員編輯或刪除專案後，刷新頁面看到的仍是舊數據
- 操作延遲高達數十秒甚至需要手動強制刷新
- 用戶懷疑操作是否成功，可能導致重複操作

**根本原因**：
- Vercel Blob Storage 使用 CDN 分發，默認會緩存靜態資源
- `readProjectData()` 直接使用 `fetch(dataBlob.url)` 讀取數據
- 瀏覽器 HTTP 緩存、CDN 緩存、Next.js 數據緩存層層疊加
- 即使數據已成功寫入 Blob，讀取時仍可能返回緩存中的舊版本

**安全風險**：
- 違反了數據庫 ACID 原則中的「一致性」要求
- 「寫入成功但讀取失敗」的狀態會誤導用戶
- 可能導致基於錯誤信息的重複操作或數據混亂

---

### 改進 6：強制讀取最新數據（緩存破壞機制）

**做法**：
```typescript
// app/lib/blob-storage.ts
response = await fetch(`${dataBlob.url}?t=${Date.now()}`, {
  cache: 'no-store',
  headers: {
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
});
```

**原理**：
- 添加時間戳參數 `?t=${Date.now()}` 使每次請求的 URL 唯一
- 設置 `cache: 'no-store'` 禁用 fetch 緩存
- HTTP 標頭強制所有中間緩存層重新驗證

**效果**：
- ✅ 確保「讀己之寫」一致性保證
- ✅ 操作後立即可見變更（延遲從 0-60 秒降至 1-2 秒）
- ✅ 防止用戶因看到舊數據而誤判操作失敗
- ✅ 提升用戶對系統的信任度

---

### 改進 7：禁用 Next.js API 路由緩存

**做法**：
在所有讀取或寫入數據的 API 路由中添加：
```typescript
export const revalidate = 0;          // 禁用靜態緩存
export const dynamic = 'force-dynamic'; // 強制動態渲染
```

**影響範圍**：
- `app/api/projects/route.ts` - 專案列表 GET/POST
- `app/api/projects/[id]/route.ts` - 單個專案 GET/PATCH/DELETE
- `app/api/projects/reorder/route.ts` - 專案排序
- `app/api/settings/ui-display/route.ts` - UI 設定讀寫
- `app/api/settings/reset-ui/route.ts` - UI 設定重置
- `app/api/admin/init-data/route.ts` - 數據初始化

**效果**：
- ✅ 每次 API 請求都重新執行，不使用緩存結果
- ✅ 配合緩存破壞機制，形成完整的數據一致性保障
- ✅ 確保前端總是獲取最新的數據狀態

---

## 📋 目前安全防護機制

| 防護層 | 機制 | 觸發條件 |
|------|------|--------|
| **第一層** | 資料完整性驗證 | 讀取時檢查必要欄位 |
| **第二層** | 空資料保護 | 檢測到空資料且現有資料非空時拋錯 |
| **第三層** | 安全鎖標記 | 記錄每次寫入是否經過驗證（`VERIFIED` or `FORCED`） |
| **第四層** | 本地備份模式鎖定 | `USE_LOCAL_BACKUP=true` 時禁止所有寫入 |
| **第五層** | 管理員授權驗證 | 所有寫入操作都需驗證密碼 |
| **第六層** | CDN 緩存破壞 | 每次讀取都添加時間戳參數，繞過所有緩存層 |
| **第七層** | Next.js 緩存禁用 | API 路由強制動態渲染，不使用靜態緩存 |

---

## 📈 對比表

| 方面 | 改進前 | 改進後 |
|------|--------|--------|
| 讀取失敗處理 | 靜默返回預設值 | 拋錯並返回詳細訊息 |
| 本地備份模式 | 無防護，易覆蓋生產資料 | 自動鎖定所有寫入 |
| 錯誤訊息 | 英文且簡略 | 雙語訊息，含原始錯誤碼 |
| 密碼管理 | 冗長的 UI 分頁 | 完全移除，精簡化 |
| 本地開發 | 需完整配置 Vercel | 優雅降級，無需 token |
| 數據一致性 | CDN 緩存導致延遲 0-60 秒 | 強制讀取最新數據，延遲 1-2 秒 |
| 操作可見性 | 用戶無法確認操作是否成功 | 操作後立即可見變更 |

---

## 🛡️ 核心安全原則（不可妥協）

### 原則 1：永不自動覆蓋
✅ **執行**：管理員明確授權的操作
❌ **禁止**：在啟動、錯誤処理、或中間件中自動寫入

### 原則 2：讀取失敗拋錯誤
✅ **執行**：向上拋出詳細錯誤，讓前端顯示警告
❌ **禁止**：靜默使用預設值繼續運行

### 原則 3：多層驗證
✅ **執行**：完整性 → 空資料檢查 → 授權驗證
❌ **禁止**：單一驗證點或無驗證

### 原則 4：區分情況
✅ **執行**：明確區分「檔案不存在」vs「讀取失敗」vs「資料為空」
❌ **禁止**：將三種情況混為一談

### 原則 5：保證數據一致性
✅ **執行**：讀取時強制繞過所有緩存層，確保「讀己之寫」
❌ **禁止**：依賴緩存機制，允許用戶看到過時數據

---

## 🎯 實施成果

**資料安全等級**：從「易丟失」升級到「多層保護 + 一致性保障」

**具體成果**：
- ✅ 讀取失敗時明確反饋，不再誤觸初始化
- ✅ 本地備份模式自動鎖定寫入，防止覆蓋生產資料
- ✅ 所有 API 端點使用統一的雙語錯誤格式
- ✅ 開發者在本地無需 Vercel 配置即可運行
- ✅ 後台 UI 更簡潔，移除非必要功能
- ✅ CDN 緩存問題解決，確保數據即時可見
- ✅ 操作延遲從數十秒降至 1-2 秒，用戶體驗大幅提升

---

## 📝 開發者須知

### 本地開發
- 無需設定 `BLOB_READ_WRITE_TOKEN`，系統會自動優雅降級
- 本地變更只在記憶體中，刷新頁面後消失（正常行為）

### 部署前檢查清單
- [ ] 確認 `.env` 中 `NEXT_PUBLIC_USE_LOCAL_BACKUP` 為空或 `false`
- [ ] 確認 `ADMIN_PASSWORD` 已設定
- [ ] 本地測試完整的增刪改查流程
- [ ] 檢查控制台是否有任何警告訊息

### 緊急還原
- 若資料被誤覆蓋，可透過後台管理頁面的「批量匯入」功能還原已備份資料
- 無法自動回滾，必須手動匯入

---

## 🎓 設計思路

這次改進的核心理念：
1. **防禦優先於便利**：寧可多一層檢查，也不要冒險自動化
2. **明確優於隱含**：錯誤必須清楚呈現，不能靜默失敗
3. **開發友善於繁瑣**：本地開發無需複雜配置
4. **生產謹慎於靈活**：生產環境嚴格把關，不允許有灰色地帶
5. **一致性優於性能**：寧可犧牲緩存帶來的性能，也要保證數據一致性

---

**最後更新**：2025-10-23
**狀態**：✅ 全面實施（第三階段）
**下次考慮**：實施自動備份機制、審計日誌系統
