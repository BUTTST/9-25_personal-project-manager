---
globs: "app/lib/**/*.ts,app/api/**/*.ts,app/api/**/route.ts"
---
# 資料安全與防護規則（Supabase 版）

> ⚠️ **重要**：本規則的優先級最高，違反任何規則都可能導致生產資料永久丟失！
> 📅 更新日期：2025-10-28 - 已遷移至 Supabase PostgreSQL + Storage

## 🚨 核心安全原則（絕不妥協）

### 原則 1：永不自動覆寫生產資料
**禁止**：任何在全域範圍、自動執行、或預設啟動時可能覆寫現有資料的邏輯。

❌ **嚴禁模式**：
```typescript
// 禁止：在 GET 端點中自動初始化
export async function GET() {
  const { data: projects } = await supabaseAdmin.from('projects').select('*');
  if (!projects || projects.length === 0) {
    // ⛔ 絕對禁止自動插入範例資料！
    await supabaseAdmin.from('projects').insert(sampleProjects);
  }
}

// 禁止：在應用啟動時自動覆寫
if (!existingData || existingData.length === 0) {
  await supabaseAdmin.from('projects').delete().neq('id', ''); // ⛔ 危險！
  await supabaseAdmin.from('projects').insert(defaultData); // ⛔ 危險！
}

// 禁止：無條件刪除/更新
await supabaseAdmin.from('projects').delete(); // ⛔ 沒有 WHERE 條件
```

✅ **正確模式**：
```typescript
// 正確：需要管理員授權的手動初始化
export async function POST(request: NextRequest) {
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }
  
  // 明確的用戶操作，有日誌記錄
  console.log('⚠️ 管理員觸發手動初始化');
  
  // 使用事務確保原子性
  const { data, error } = await supabaseAdmin
    .from('projects')
    .insert(sampleProjects);
    
  if (error) {
    console.error('初始化失敗:', error);
    return NextResponse.json({ error: '初始化失敗' }, { status: 500 });
  }
  
  return NextResponse.json({ success: true });
}
```

### 原則 2：讀取失敗不等於資料為空
**禁止**：將讀取錯誤靜默處理為空資料，進而觸發初始化。

❌ **嚴禁模式**：
```typescript
// 禁止：將讀取失敗當作空資料
async function getProjects() {
  try {
    const { data } = await supabaseAdmin.from('projects').select('*');
    return data || []; // ⛔ 危險：error 時也返回空陣列
  } catch (error) {
    return []; // ⛔ 危險：可能誤判為首次部署
  }
}

// 禁止：靜默失敗
const projects = await getProjects();
if (projects.length === 0) {
  // 可能是讀取失敗，不是真的為空！
  await initializeData(); // ⛔ 不安全
}
```

✅ **正確模式（Supabase 版本）**：
```typescript
// 正確：區分錯誤和空資料
export async function getProjects() {
  if (!supabaseAdmin) {
    throw new Error('Supabase admin client not available');
  }
  
  const { data, error } = await supabaseAdmin
    .from('projects')
    .select('*')
    .order('sort_order');
  
  // 明確處理錯誤
  if (error) {
    console.error('Database query failed:', error);
    throw new Error(`Failed to fetch projects: ${error.message}`);
  }
  
  // data 為 null 或 [] 都是合法的（真正的空資料）
  return data || [];
}

// 使用時處理異常
try {
  const projects = await getProjects();
  // 這裡的 projects.length === 0 是真正的空資料
} catch (error) {
  // 這才是讀取失敗，不應觸發初始化
  console.error('Cannot read projects:', error);
  return NextResponse.json({ error: '暫時無法讀取資料' }, { status: 503 });
}
```

### 原則 3：使用資料庫層級保護
**必須**：利用 Supabase 的內建安全機制，而非手動驗證。

✅ **Supabase 安全機制**：
```typescript
// ✅ 使用 PostgreSQL Constraints 保護資料完整性
// 在資料表建立時設定：
// - NOT NULL 約束（必填欄位）
// - CHECK 約束（值範圍驗證）
// - UNIQUE 約束（防止重複）
// - FOREIGN KEY 約束（關聯完整性）

// ✅ 使用 Row Level Security (RLS) 控制存取
// projects 表的 RLS 政策：
// - SELECT: 允許公開讀取（WHERE hidden = false）
// - INSERT/UPDATE/DELETE: 僅後端 service_role 可操作

// API 路由中的正確模式：
export async function POST(request: NextRequest) {
  // 第一層：驗證管理員權限
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }

  // 第二層：驗證 Supabase admin client
  if (!supabaseAdmin) {
    return NextResponse.json({ error: 'Database not available' }, { status: 503 });
  }

  // 第三層：驗證輸入資料
  const body = await request.json();
  if (!body.dateAndFileName || !body.description) {
    return NextResponse.json({ error: '必填欄位缺失' }, { status: 400 });
  }

  // 第四層：執行資料庫操作（PostgreSQL 會自動驗證 constraints）
  const { data, error } = await supabaseAdmin
    .from('projects')
    .insert({
      date_and_file_name: body.dateAndFileName,
      description: body.description,
      // ... 其他欄位
    })
    .select()
    .single();

  // 第五層：處理資料庫錯誤
  if (error) {
    console.error('Database insert failed:', error);
    // PostgreSQL 錯誤碼提供詳細資訊
    if (error.code === '23505') { // unique_violation
      return NextResponse.json({ error: '專案已存在' }, { status: 409 });
    }
    return NextResponse.json({ error: '新增失敗' }, { status: 500 });
  }

  // 記錄操作日誌
  console.log('✅ 新增專案成功:', data.id);
  
  return NextResponse.json(data, { status: 201 });
}
```

## 🔒 API 端點安全規範

### 規範 1：所有寫入端點都需要驗證
```typescript
// ✅ 正確：每個修改資料的端點都要驗證
export async function POST(request: NextRequest) {
  // 必須：驗證管理員權限
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權訪問' }, { status: 401 });
  }
  
  // 繼續處理...
}
```

### 規範 2：危險操作必須是 POST，不能是 GET
```typescript
// ❌ 禁止：GET 請求中修改資料
export async function GET() {
  await writeProjectData(data); // ⛔ GET 不應該有副作用
}

// ✅ 正確：使用 POST 進行寫入操作
export async function POST(request: NextRequest) {
  // 驗證 → 讀取 → 修改 → 寫入
}
```

### 規範 3：初始化端點必須明確授權（且禁用自動初始化）
```typescript
// ✅ 正確的初始化端點（手動、明確授權）
export async function POST(request: NextRequest) {
  // 1. 驗證管理員
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }
  
  // 2. 讀取現有資料
  const existingData = await readProjectData();
  
  // 3. 確認用戶知道後果
  const { confirmOverwrite } = await request.json();
  if (!isEmptyData(existingData) && !confirmOverwrite) {
    return NextResponse.json({
      warning: '現有資料將被覆蓋',
      existingProjects: existingData.projects.length,
      requireConfirmation: true
    }, { status: 400 });
  }
  
  // 4. 記錄詳細日誌
  console.log('⚠️ 管理員強制初始化:', {
    timestamp: new Date().toISOString(),
    existingProjects: existingData.projects.length,
    willOverwrite: !isEmptyData(existingData)
  });
  
  // 5. 執行初始化
  await writeProjectData(sampleData, true);
  
  return NextResponse.json({ success: true });
}

// ⛔ 自動初始化端點已停用：/api/initialize
// 僅回傳提示訊息，避免任何讀取失敗時誤觸初始化
```

## 🛡️ Supabase 特定注意事項

### 注意 1：使用 Service Role Key 繞過 RLS
```typescript
// ⚠️ Service Role Key 擁有完全權限，僅在後端使用
import { supabaseAdmin } from '@/lib/supabase';

// ❌ 錯誤：在前端使用 service role key
// 這會暴露完全權限給所有用戶

// ✅ 正確：僅在 API routes 使用
export async function POST(request: NextRequest) {
  // 驗證管理員權限後，才使用 supabaseAdmin
  if (!verifyAdmin(request)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // 現在可以安全使用 supabaseAdmin
  const { data, error } = await supabaseAdmin
    .from('projects')
    .insert(newProject);
}
```

### 注意 2：Row Level Security (RLS) 政策
```typescript
// ✅ 前端使用 supabase（受 RLS 限制）
import { supabase } from '@/lib/supabase';

// 只能讀取公開資料
const { data } = await supabase
  .from('projects')
  .select('*')
  .eq('hidden', false); // RLS 會自動強制此條件

// ✅ 後端使用 supabaseAdmin（繞過 RLS）
const { data } = await supabaseAdmin
  .from('projects')
  .select('*'); // 可讀取所有資料，包括 hidden = true
```

### 注意 3：PostgreSQL 事務與原子性
```typescript
// ✅ Supabase 支援事務（與 Blob 的主要差異）
// 使用 rpc 執行複雜事務
const { data, error } = await supabaseAdmin.rpc('batch_update_projects', {
  project_ids: ['id1', 'id2'],
  new_status: 'completed'
});

// ✅ 批量操作的原子性
const { data, error } = await supabaseAdmin
  .from('projects')
  .insert([project1, project2, project3]); // 全部成功或全部失敗

// 如果需要跨表操作，使用 PostgreSQL 事務：
// BEGIN; ... COMMIT; 或 ROLLBACK;
```

### 注意 4：連接池與超時
```typescript
// ⚠️ Serverless 環境的連接限制
// Supabase 免費版：最多 60 個並發連接

// ✅ 正確：使用 supabaseAdmin 已經有連接池管理
// 無需手動管理連接

// ⚠️ 查詢超時設定
const { data, error } = await supabaseAdmin
  .from('projects')
  .select('*')
  .abortSignal(AbortSignal.timeout(5000)); // 5 秒超時
```

## 📋 代碼審查檢查清單

在實作或審查涉及資料寫入的代碼時，必須確認：

### 寫入操作檢查
- [ ] 是否需要管理員授權？已實作驗證？
- [ ] 是否使用 `forceWrite` 參數？是否必要？
- [ ] 是否有資料完整性驗證？
- [ ] 是否有空資料保護？
- [ ] 是否更新了 `metadata.lastUpdated`？
- [ ] 是否記錄了詳細的操作日誌？

### 讀取操作檢查
- [ ] 是否區分了「不存在」和「讀取失敗」？
- [ ] 錯誤處理是否會意外觸發初始化？
- [ ] 是否有適當的錯誤日誌？
- [ ] 是否考慮了冷啟動情況？

### 初始化端點檢查
- [ ] 是否是 POST 而非 GET？
- [ ] 是否需要管理員密碼？
- [ ] 是否會在用戶不知情時執行？
- [ ] 是否有覆蓋現有資料的風險？
- [ ] 是否有確認機制？
- [ ] 是否有詳細的操作日誌？

### 自動化邏輯檢查
- [ ] 是否在啟動時自動執行？→ 如果是，必須重新設計
- [ ] 是否在錯誤處理中觸發寫入？→ 如果是，必須移除
- [ ] 是否假設讀取失敗等於空資料？→ 如果是，必須修正

## 🚫 絕對禁止的模式

### 1. 自動初始化端點
```typescript
// ⛔ 絕對禁止
export async function GET() {
  const data = await readProjectData();
  if (isEmptyData(data)) {
    await writeProjectData(sampleData, true);
  }
  return NextResponse.json(data);
}
```

### 2. 錯誤處理中的靜默寫入
```typescript
// ⛔ 絕對禁止
try {
  const data = await readProjectData();
} catch (error) {
  await writeProjectData(defaultData, true); // 危險！
}
```

### 3. 預設啟用強制寫入
```typescript
// ⛔ 絕對禁止
async function saveData(data) {
  await writeProjectData(data, true); // forceWrite 應該是例外，不是常態
}
```

### 4. 無驗證的寫入端點
```typescript
// ⛔ 絕對禁止
export async function POST(request: NextRequest) {
  const data = await request.json();
  await writeProjectData(data); // 沒有驗證！
}
```

### 5. 在 middleware 或全域檔案中寫入
```typescript
// ⛔ 絕對禁止
// middleware.ts 或 layout.tsx 中
const data = await readProjectData();
if (!data) {
  await writeProjectData(defaultData); // 太早、太自動化
}
```

## ✅ 推薦的安全模式

### 模式 1：讀取-修改-寫入模式
```typescript
export async function POST(request: NextRequest) {
  // 1. 驗證
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }

  // 2. 讀取
  const data = await readProjectData();
  
  // 3. 修改
  const updates = await request.json();
  const updatedData = {
    ...data,
    projects: [...data.projects, newProject],
    metadata: {
      ...data.metadata,
      lastUpdated: Date.now(),
      totalProjects: data.projects.length + 1
    }
  };
  
  // 4. 驗證
  const { isValid, errors } = validateDataIntegrity(updatedData);
  if (!isValid) {
    return NextResponse.json({ error: errors }, { status: 400 });
  }
  
  // 5. 寫入（不使用 forceWrite）
  await writeProjectData(updatedData);
  
  return NextResponse.json({ success: true });
}
```

### 模式 2：防禦性讀取
```typescript
async function safeReadProjectData(): Promise<ProjectData> {
  try {
    // 確認檔案存在
    const { blobs } = await list();
    const dataBlob = blobs.find(blob => blob.pathname === BLOB_FILENAME);
    
    if (!dataBlob) {
      console.log('📄 檔案不存在，這是正常的首次部署情況');
      return defaultProjectData;
    }

    // 讀取內容
    const response = await fetch(dataBlob.url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    
    // 驗證資料
    if (!validateProjectData(data)) {
      throw new Error('資料格式驗證失敗');
    }

    return data;
    
  } catch (error) {
    console.error('💥 讀取失敗:', error);
    // 不返回預設值，拋出錯誤讓調用者處理
    throw new Error(`無法讀取專案資料: ${error.message}`);
  }
}
```

### 模式 3：備份前寫入
```typescript
async function safeWriteProjectData(data: ProjectData) {
  // 讀取現有資料作為備份參考
  let existingData: ProjectData | null = null;
  try {
    existingData = await readProjectData();
  } catch (error) {
    console.warn('無法讀取現有資料進行備份');
  }

  // 如果有現有資料，記錄在元資料中
  if (existingData && !isEmptyData(existingData)) {
    data.metadata.previousBackup = {
      timestamp: existingData.metadata.lastUpdated,
      projectCount: existingData.projects.length
    };
  }

  // 寫入
  await writeProjectData(data);
}
```

## 📝 實作新功能時的安全流程

當需要實作涉及資料寫入的新功能時，遵循以下流程：

1. **設計階段**
   - [ ] 是否真的需要寫入資料？
   - [ ] 能否用純讀取實現？
   - [ ] 寫入的觸發條件是什麼？

2. **實作階段**
   - [ ] 實作管理員驗證
   - [ ] 實作資料驗證
   - [ ] 實作錯誤處理（不靜默失敗）
   - [ ] 添加詳細日誌

3. **測試階段**
   - [ ] 測試正常寫入流程
   - [ ] 測試驗證失敗情況
   - [ ] 測試未授權訪問
   - [ ] 測試錯誤恢復
   - [ ] 測試冷啟動情況

4. **部署階段**
   - [ ] 確認現有資料已備份
   - [ ] 部署後立即測試讀取
   - [ ] 監控錯誤日誌
   - [ ] 準備回滾計畫

## 🆘 緊急情況處理

如果發現資料被意外覆寫或刪除：

1. **立即停止**：停止所有自動化部署
2. **檢查備份**：
   - Supabase 自動備份（Point-in-Time Recovery）
   - 本地備份檔案
   - Git 歷史記錄
3. **使用還原功能**：
   - Supabase 控制台的 Point-in-Time Recovery
   - 或透過管理後台的匯入功能還原
4. **分析原因**：檢查 Supabase 日誌和應用日誌找出觸發原因
5. **修復代碼**：根據本規則修正問題
6. **加強防護**：
   - 檢查 RLS 政策是否正確
   - 確認 constraints 是否足夠
   - 添加更多資料庫層級的保護

## 🎯 總結：黃金法則（Supabase 版）

1. **永不信任自動化**：任何自動執行的寫入邏輯都是風險
2. **讀取失敗拋錯誤**：明確處理 `error`，不要靜默返回空資料
3. **利用資料庫保護**：使用 PostgreSQL constraints、RLS、事務
4. **Service Role 需授權**：`supabaseAdmin` 僅在驗證後使用
5. **詳細日誌記錄**：記錄所有資料庫操作和錯誤
6. **區分情況處理**：`error` ≠ `data === null` ≠ `data.length === 0`
7. **善用 PostgreSQL 錯誤碼**：根據錯誤碼提供精確的錯誤訊息

### Supabase 特有優勢

✅ **PostgreSQL 提供的保護**：
- Constraints 自動驗證資料完整性
- RLS 自動控制存取權限
- Triggers 可實現自動審計
- 事務保證原子性

✅ **不再需要手動實作**：
- ❌ `forceWrite` 參數（RLS 取代）
- ❌ `safetyCheck` 標記（Timestamps 自動管理）
- ❌ 空資料保護（Constraints 處理）
- ❌ 手動備份標記（Point-in-Time Recovery）

---

> 💡 **記住**：Supabase PostgreSQL 提供企業級資料保護。
> 善用資料庫層級的安全機制，而非在應用層重複實作。
> RLS + Constraints + 事務 = 強大的資料安全保障。
