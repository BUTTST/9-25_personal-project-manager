---
globs: "app/lib/**/*.ts,app/api/**/*.ts,app/api/**/route.ts"
---
# 資料安全與防護規則

> ⚠️ **重要**：本規則的優先級最高，違反任何規則都可能導致生產資料永久丟失！

## 🚨 核心安全原則（絕不妥協）

### 原則 1：永不自動覆寫生產資料
**禁止**：任何在全域範圍、自動執行、或預設啟動時可能覆寫現有資料的邏輯。

❌ **嚴禁模式**：
```typescript
// 禁止：在 GET 端點中自動初始化
export async function GET() {
  const data = await readProjectData();
  if (isEmptyData(data)) {
    await writeProjectData(sampleData, true); // ⛔ 絕對禁止！
  }
}

// 禁止：在應用啟動時自動覆寫
if (!existingData || existingData.projects.length === 0) {
  await writeProjectData(defaultData, true); // ⛔ 危險！
}

// 禁止：預設啟用 forceWrite
await writeProjectData(data, true); // ⛔ 除非有明確的管理員授權
```

✅ **正確模式**：
```typescript
// 正確：需要管理員授權的手動初始化
export async function POST(request: NextRequest) {
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }
  
  // 明確的用戶操作，有日誌記錄
  console.log('⚠️ 管理員觸發手動初始化');
  await writeProjectData(sampleData, true);
}
```

### 原則 2：讀取失敗不等於資料為空
**禁止**：將讀取錯誤靜默處理為空資料，進而觸發初始化。

❌ **嚴禁模式**：
```typescript
// 禁止：將讀取失敗當作空資料
async function readProjectData() {
  try {
    const response = await fetch(blobUrl);
    return await response.json();
  } catch (error) {
    return defaultProjectData; // ⛔ 危險：可能誤判為首次部署
  }
}

// 禁止：靜默失敗
const data = await readProjectData();
if (!data || data.projects.length === 0) {
  // 可能是讀取失敗，不是真的為空！
  await initializeData(); // ⛔ 不安全
}
```

✅ **正確模式**：
```typescript
// 正確：區分「不存在」和「讀取失敗」
async function readProjectData(): Promise<ProjectData> {
  try {
    const { blobs } = await list();
    const dataBlob = blobs.find(blob => blob.pathname === BLOB_FILENAME);
    
    if (!dataBlob) {
      // 檔案確實不存在
      console.log('📄 檔案不存在，返回預設空資料');
      return defaultProjectData;
    }

    const response = await fetch(dataBlob.url);
    if (!response.ok) {
      // 讀取失敗，拋出錯誤
      throw new Error(`Blob 讀取失敗: ${response.status}`);
    }

    const data = await response.json();
    return data;
    
  } catch (error) {
    // 記錄詳細錯誤，但不自動初始化
    console.error('💥 讀取資料時發生錯誤:', error);
    throw error; // 向上拋出，不要靜默處理
  }
}
```

### 原則 3：多層驗證才能寫入
**必須**：每次寫入前執行完整的安全檢查鏈。

✅ **必須實施的三層驗證**：
```typescript
async function writeProjectData(data: ProjectData, forceWrite = false) {
  // 第一層：資料完整性驗證
  const { isValid, errors } = validateDataIntegrity(data);
  if (!isValid && !forceWrite) {
    console.error('❌ 資料完整性驗證失敗:', errors);
    throw new Error(`資料驗證失敗: ${errors.join(', ')}`);
  }

  // 第二層：空資料保護
  if (!forceWrite && isEmptyData(data)) {
    console.error('🚨 警告：嘗試寫入空資料！');
    
    // 讀取現有資料進行比對
    const existingData = await readExistingDataForComparison();
    if (existingData && !isEmptyData(existingData)) {
      console.error('🛑 資料保護：阻止空資料覆蓋現有資料');
      throw new Error('SAFETY_LOCK: 阻止空資料覆蓋。使用 forceWrite=true 強制執行。');
    }
  }

  // 第三層：記錄安全檢查標記
  const updatedData = {
    ...data,
    metadata: {
      ...data.metadata,
      lastUpdated: Date.now(),
      writeTimestamp: Date.now(),
      safetyCheck: forceWrite ? 'FORCED' : 'VERIFIED',
      writeReason: forceWrite ? 'Admin forced write' : 'Normal update'
    }
  };

  // 執行寫入
  console.log('💾 執行資料寫入:', {
    projects: updatedData.projects.length,
    safetyCheck: updatedData.metadata.safetyCheck
  });
  
  return await put(BLOB_FILENAME, JSON.stringify(updatedData, null, 2), {
    access: 'public',
    addRandomSuffix: false
  });
}
```

## 🔒 API 端點安全規範

### 規範 1：所有寫入端點都需要驗證
```typescript
// ✅ 正確：每個修改資料的端點都要驗證
export async function POST(request: NextRequest) {
  // 必須：驗證管理員權限
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權訪問' }, { status: 401 });
  }
  
  // 繼續處理...
}
```

### 規範 2：危險操作必須是 POST，不能是 GET
```typescript
// ❌ 禁止：GET 請求中修改資料
export async function GET() {
  await writeProjectData(data); // ⛔ GET 不應該有副作用
}

// ✅ 正確：使用 POST 進行寫入操作
export async function POST(request: NextRequest) {
  // 驗證 → 讀取 → 修改 → 寫入
}
```

### 規範 3：初始化端點必須明確授權
```typescript
// ✅ 正確的初始化端點
export async function POST(request: NextRequest) {
  // 1. 驗證管理員
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }
  
  // 2. 讀取現有資料
  const existingData = await readProjectData();
  
  // 3. 確認用戶知道後果
  const { confirmOverwrite } = await request.json();
  if (!isEmptyData(existingData) && !confirmOverwrite) {
    return NextResponse.json({
      warning: '現有資料將被覆蓋',
      existingProjects: existingData.projects.length,
      requireConfirmation: true
    }, { status: 400 });
  }
  
  // 4. 記錄詳細日誌
  console.log('⚠️ 管理員強制初始化:', {
    timestamp: new Date().toISOString(),
    existingProjects: existingData.projects.length,
    willOverwrite: !isEmptyData(existingData)
  });
  
  // 5. 執行初始化
  await writeProjectData(sampleData, true);
  
  return NextResponse.json({ success: true });
}
```

## 🛡️ Vercel Blob 特定注意事項

### 注意 1：冷啟動延遲
Serverless Functions 冷啟動時，Blob 可能尚未就緒：
```typescript
// ✅ 使用重試機制
async function readProjectDataWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await readProjectData();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      console.log(`🔄 讀取失敗，重試 ${i + 1}/${maxRetries}...`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
```

### 注意 2：檔案存在性檢查
```typescript
// ✅ 先列出檔案，再讀取
const { blobs } = await list();
const dataBlob = blobs.find(blob => blob.pathname === BLOB_FILENAME);

if (!dataBlob) {
  // 確實不存在
} else {
  // 存在，可以安全讀取
}
```

### 注意 3：寫入不是原子操作
```typescript
// ⚠️ 注意：Blob 寫入會完全覆蓋
// 沒有事務保護，一旦寫入就無法回滾
// 因此寫入前的驗證至關重要

// ✅ 建議：在寫入前創建備份標記
const updatedData = {
  ...data,
  metadata: {
    ...data.metadata,
    previousVersion: existingData.metadata.version,
    previousUpdateTime: existingData.metadata.lastUpdated
  }
};
```

## 📋 代碼審查檢查清單

在實作或審查涉及資料寫入的代碼時，必須確認：

### 寫入操作檢查
- [ ] 是否需要管理員授權？已實作驗證？
- [ ] 是否使用 `forceWrite` 參數？是否必要？
- [ ] 是否有資料完整性驗證？
- [ ] 是否有空資料保護？
- [ ] 是否更新了 `metadata.lastUpdated`？
- [ ] 是否記錄了詳細的操作日誌？

### 讀取操作檢查
- [ ] 是否區分了「不存在」和「讀取失敗」？
- [ ] 錯誤處理是否會意外觸發初始化？
- [ ] 是否有適當的錯誤日誌？
- [ ] 是否考慮了冷啟動情況？

### 初始化端點檢查
- [ ] 是否是 POST 而非 GET？
- [ ] 是否需要管理員密碼？
- [ ] 是否會在用戶不知情時執行？
- [ ] 是否有覆蓋現有資料的風險？
- [ ] 是否有確認機制？
- [ ] 是否有詳細的操作日誌？

### 自動化邏輯檢查
- [ ] 是否在啟動時自動執行？→ 如果是，必須重新設計
- [ ] 是否在錯誤處理中觸發寫入？→ 如果是，必須移除
- [ ] 是否假設讀取失敗等於空資料？→ 如果是，必須修正

## 🚫 絕對禁止的模式

### 1. 自動初始化端點
```typescript
// ⛔ 絕對禁止
export async function GET() {
  const data = await readProjectData();
  if (isEmptyData(data)) {
    await writeProjectData(sampleData, true);
  }
  return NextResponse.json(data);
}
```

### 2. 錯誤處理中的靜默寫入
```typescript
// ⛔ 絕對禁止
try {
  const data = await readProjectData();
} catch (error) {
  await writeProjectData(defaultData, true); // 危險！
}
```

### 3. 預設啟用強制寫入
```typescript
// ⛔ 絕對禁止
async function saveData(data) {
  await writeProjectData(data, true); // forceWrite 應該是例外，不是常態
}
```

### 4. 無驗證的寫入端點
```typescript
// ⛔ 絕對禁止
export async function POST(request: NextRequest) {
  const data = await request.json();
  await writeProjectData(data); // 沒有驗證！
}
```

### 5. 在 middleware 或全域檔案中寫入
```typescript
// ⛔ 絕對禁止
// middleware.ts 或 layout.tsx 中
const data = await readProjectData();
if (!data) {
  await writeProjectData(defaultData); // 太早、太自動化
}
```

## ✅ 推薦的安全模式

### 模式 1：讀取-修改-寫入模式
```typescript
export async function POST(request: NextRequest) {
  // 1. 驗證
  const password = request.headers.get('x-admin-password');
  if (!password || password !== process.env.ADMIN_PASSWORD) {
    return NextResponse.json({ error: '未授權' }, { status: 401 });
  }

  // 2. 讀取
  const data = await readProjectData();
  
  // 3. 修改
  const updates = await request.json();
  const updatedData = {
    ...data,
    projects: [...data.projects, newProject],
    metadata: {
      ...data.metadata,
      lastUpdated: Date.now(),
      totalProjects: data.projects.length + 1
    }
  };
  
  // 4. 驗證
  const { isValid, errors } = validateDataIntegrity(updatedData);
  if (!isValid) {
    return NextResponse.json({ error: errors }, { status: 400 });
  }
  
  // 5. 寫入（不使用 forceWrite）
  await writeProjectData(updatedData);
  
  return NextResponse.json({ success: true });
}
```

### 模式 2：防禦性讀取
```typescript
async function safeReadProjectData(): Promise<ProjectData> {
  try {
    // 確認檔案存在
    const { blobs } = await list();
    const dataBlob = blobs.find(blob => blob.pathname === BLOB_FILENAME);
    
    if (!dataBlob) {
      console.log('📄 檔案不存在，這是正常的首次部署情況');
      return defaultProjectData;
    }

    // 讀取內容
    const response = await fetch(dataBlob.url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    
    // 驗證資料
    if (!validateProjectData(data)) {
      throw new Error('資料格式驗證失敗');
    }

    return data;
    
  } catch (error) {
    console.error('💥 讀取失敗:', error);
    // 不返回預設值，拋出錯誤讓調用者處理
    throw new Error(`無法讀取專案資料: ${error.message}`);
  }
}
```

### 模式 3：備份前寫入
```typescript
async function safeWriteProjectData(data: ProjectData) {
  // 讀取現有資料作為備份參考
  let existingData: ProjectData | null = null;
  try {
    existingData = await readProjectData();
  } catch (error) {
    console.warn('無法讀取現有資料進行備份');
  }

  // 如果有現有資料，記錄在元資料中
  if (existingData && !isEmptyData(existingData)) {
    data.metadata.previousBackup = {
      timestamp: existingData.metadata.lastUpdated,
      projectCount: existingData.projects.length
    };
  }

  // 寫入
  await writeProjectData(data);
}
```

## 📝 實作新功能時的安全流程

當需要實作涉及資料寫入的新功能時，遵循以下流程：

1. **設計階段**
   - [ ] 是否真的需要寫入資料？
   - [ ] 能否用純讀取實現？
   - [ ] 寫入的觸發條件是什麼？

2. **實作階段**
   - [ ] 實作管理員驗證
   - [ ] 實作資料驗證
   - [ ] 實作錯誤處理（不靜默失敗）
   - [ ] 添加詳細日誌

3. **測試階段**
   - [ ] 測試正常寫入流程
   - [ ] 測試驗證失敗情況
   - [ ] 測試未授權訪問
   - [ ] 測試錯誤恢復
   - [ ] 測試冷啟動情況

4. **部署階段**
   - [ ] 確認現有資料已備份
   - [ ] 部署後立即測試讀取
   - [ ] 監控錯誤日誌
   - [ ] 準備回滾計畫

## 🆘 緊急情況處理

如果發現資料被意外覆寫：

1. **立即停止**：停止所有自動化部署
2. **檢查備份**：查看本地備份或 Vercel Blob 歷史版本
3. **使用還原端點**：透過管理後台的匯入功能還原
4. **分析原因**：檢查日誌找出觸發原因
5. **修復代碼**：根據本規則修正問題
6. **加強防護**：添加更多驗證層

## 🎯 總結：黃金法則

1. **永不信任自動化**：任何自動執行的寫入邏輯都是風險
2. **讀取失敗拋錯誤**：不要靜默處理，讓調用者決定
3. **多層驗證保護**：完整性 → 空資料檢查 → 安全鎖
4. **強制寫入需授權**：`forceWrite=true` 必須有明確理由
5. **詳細日誌記錄**：每次寫入都要記錄原因和內容
6. **區分情況處理**：「不存在」≠「讀取失敗」≠「資料為空」

---

> 💡 **記住**：在 Serverless + Object Storage 的世界裡，資料一旦覆寫就無法回滾。
> 寧可多一層檢查，也不要冒險自動化。安全永遠比方便更重要。
